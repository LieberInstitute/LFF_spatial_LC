---
title: "01-Make_cluster_DGEs_withMinSpots_reqmnt"
author: "Bernie Mulvey"
date: "2025-04-26"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.height = 10,fig.width = 7,include = FALSE)
#### sets tab autocompletion for directories to begin from the directory containing the .Rproj session, instead of the script's directory if different
knitr::opts_knit$set(root.dir = here::here())

library(data.table)
library(SpatialExperiment)
library(dreamlet)
library(limma)
library(edgeR)
library(gridExtra)
library(ggplot2)

## rstudio GUI tweaks
require(colorout)
ColorOut()
options("styler.addins_style_transformer" = "biocthis::bioc_style()")
##

## enable forked parallel processing with BiocParallel::multicoreParam, future::, etc. seemed to need this a couple times, but otherwise havent so its here as a preventative measure. part of this is adding the line 
# OBJC_DISABLE_INITIALIZE_FORK_SAFETY=YES
# to Renviron.site. see e.g. top response on https://stackoverflow.com/questions/73638290/python-on-mac-is-it-safe-to-set-objc-disable-initialize-fork-safety-yes-globall 
library(parallelly)
options(parallelly.supportsMulticore.disableOn="")
options(parallelly.fork.enable=TRUE)
library(BiocParallel)
options(bphost="localhost")
library(parallel) # use PSOCK clusters for best performance here

## last of all, unload the base package datasets, whose data keep getting in the way of autocompletions (e.g., Theoph is priortized over TRUE)
unloadNamespace("datasets")
```

 
## load SPE and assign hdg_svg_2575_louv_res1 clusterings as autoannotated
## Drop Br5517 (unknown anatomy/orientation), Br5276 (LC has been depleted by QC), Br5712 (unknown anatomy/orientation). Keep 6297; no LC but anatomy is right in vicinity.
```{r}
lc3 <- readRDS("processed-data/06-countsOnly_noImgData_QCed_SPE_split_to_tissSections.RDS")

louvs <- readRDS("processed-data/07_featureSelection_dimred_harmony_clustering/04-Initial_louvLeid_res0.5-1-2_clusterings.RDS")
louvs <- louvs[["HARMONYlmbna_HDG_SVG_2575"]][,.(rn,snnHARMONYlmbna_HDG_SVG_2575_louv_res1)]
setnames(louvs,2,"clusid")

autoan <- readRDS("processed-data/07_featureSelection_dimred_harmony_clustering/05b-init_clusterings_autoannoLCrapheAndGABAergic.RDS")
autoan <- autoan[["snnHARMONYlmbna_HDG_SVG_2575_louv_res1"]]
# fix 5hts so that theres not a leading digit
autoan[autoanno=="5HT.1",autoanno:="v5HT.1"]
autoan[autoanno=="5HT.2",autoanno:="v5HT.2"]

louvs <- merge.data.table(louvs,autoan,by="clusid")
louvs <- DataFrame(louvs,row.names=louvs$rn)[colnames(lc3),]

colLabels(lc3) <- louvs$autoanno
lc3 <- lc3[,!(lc3$brnum %in% paste0("Br",c(5517,5276,5712)))]
```

### to model all data jointly, we will ultimately need a cluster-sex-genotype grouping variable. then to run sex DE for one cluster we would do e.g. (LC_E2hetMale + LC_E2homMale + LC_E4hetMale + LC_E4homMale) - (LC_E2hetFem + LC_E2homFem + LC_E4hetFem + LC_E4homFem). we can get most of this made now
```{r}
# simplify APOE labels and make sexapo groups
lc3$APOE <- gsub(lc3$APOE,pattern="\\/ ",replacement="_")
lc3$APOE[lc3$APOE=="E4_E4"] <- "E4hom"
lc3$APOE[lc3$APOE=="E3_E4"] <- "E4het"
lc3$APOE[lc3$APOE=="E2_E3"] <- "E2het"
lc3$APOE[lc3$APOE=="E2_E2"] <- "E2hom"

lc3$geno_group <- paste0(lc3$Sex,"_",lc3$APOE)
```

## for plotting pseudobulk MDS by Visium slide, we need to edit the colData(spe)$Visium_slide to JUST be the slide (it still has the slide capture area ID appended to it)
```{r}
colData(lc3)$Visium_slide <- gsub(colData(lc3)$Visium_slide,pattern="^(V.....-...)_..$",replacement="\\1")

# also, things are going to get weird if we have dashes in our sample names, so remove those too
colData(lc3)$sample_id <- gsub(colData(lc3)$sample_id,pattern="-",replacement="_")

rm(louvs,autoan)
```

## pre-checks: are there clusters with <10 spots in over half the samples or over half of the smaller sex group? (ie clusters to exclude?)
```{r}
## only retain clusters for which at least 43 samples (of 85 total, i.e over half) of â‰¥10 spots each are available. do we need to drop any?
check <- as.data.table(table(colData(lc3)[,c("label","sample_id")]))
check <- check[N>=10]
check[,.N,by="label"][N<43,label]
# nope

## drop clusters where there are 20+ samples, but under 18 samples for one of the sexes (i.e., < half of the samples from the smaller group--females w 35 sections total). are there any?
check <- as.data.table(table(colData(lc3)[,c("label","Sex","sample_id")]))
check <- check[Sex=="F"&N>=10]
check[,.N,by="label"][N<18,label]
# nope
rm(check)
```

#### TOP LEVEL CLUSTER DGELists ####

# make pseudobulk object (dreamlet is v. fast at this) by sample-cluster
```{r}
ag <- dreamlet::aggregateToPseudoBulk(lc3,sample_id="sample_id",cluster_id = "label",BPPARAM = MulticoreParam(6))

# dreamlet outputs shared metadata for the samples - grab this to build one big metadata table from
tmpcd <- as.data.table(copy(colData(ag)),keep.rownames=T)
setnames(tmpcd,"rn","sample_id")

# extract number of spots in a pseudobulk sample for filtering. this is in the inverse of the format we want, list entries are sample and subentries are cluster, so rearrange to cluster listed by sample
agn <- ag@int_colData$n_cells
agn <- lapply(agn,function(x){as.data.frame(t(x))})
agn <- rbindlist(agn,idcol="samp")
agn <- melt(agn,id.vars="samp",variable.name ="label")
agn[,samp:=paste0(label,"_",samp)]
agn <- agn[value>=10]

## extract pseudobulk matrices
agm <- as.list(assays(ag))
agm <- mapply(a=agm,n=names(agm),SIMPLIFY=FALSE,function(a,n){
  colnames(a) <- paste0(n,"_",colnames(a))
  a <- a[,colnames(a) %in% agn$samp]
  a <- a[,colSums(a)>0]
  return(a)
})
rm(agn)


i<-1
for (i in c(1:length(agm))){
  if(i==1){
    megamat <- copy(as.data.table(as.data.frame(as.matrix(agm[[i]])),keep.rownames=T))
  }
  else{
    tmpmat <- copy(as.data.table(as.data.frame(as.matrix(agm[[i]])),keep.rownames=T))
    megamat <- merge.data.table(megamat,tmpmat,by="rn",all=T)
  }
}
rm(i,tmpmat)

megamat <- data.frame(megamat,row.names=megamat$rn)
megamat$rn <- NULL

# extract colData to feed into DGEList as the "samples" data
# important: add column to indicate cluster and append cluster to sample name
cds <- mapply(a=agm,n=names(agm),SIMPLIFY=FALSE,FUN=function(a,n){
  # get pbulk sample names
  cn <- as.data.table(colnames(a))
  setnames(cn,1,"clus_sample_id")
  cn[,label:=n]
  
  ## get orig sample names
  cn[,sample_id:=gsub(clus_sample_id,pattern=paste0(n,"_"),replacement="")]
  tmpcd2 <- copy(tmpcd[sample_id %in% cn$sample_id])
  tmpcd2 <- merge.data.table(tmpcd2,cn,by="sample_id")
  tmpcd2[,clus_geno_group:=paste0(label,"_",geno_group)]
  return(tmpcd2)
})

megacd <- rbindlist(cds)
megacd <- data.frame(megacd,row.names=megacd$clus_sample_id)
megacd <- megacd[colnames(megamat),]  

## get rowData as a data.table from the SPEs
tmprd <- as.data.table(rowData(lc3)) # rownames are the same as $gene_id

# clean up
rm(cds,tmpcd,agm,agcd,ag,lc3)
gc(full=T)
```


## make the single DGEList
```{r}
## drop genes with 0 counts
keep <- rowSums(megamat)>0
megamat <- megamat[keep,]
gdat <- as.data.frame(tmprd,row.names = tmprd$rn)[rownames(megamat),]
rm(tmprd)


dgel <- DGEList(counts=megamat,samples=megacd,genes=as.data.frame(gdat))
rm(megamat,megacd,gdat)

dgel <- normLibSizes(dgel,method = "TMM")
        
## smallest groupo is (several clusters) male E2 homozygote: use a low-expression cluster for this. X8 is some white matter so that should do
## for the smallest group, determine low expression cutoff
rowmn.m <- as.numeric(rowMeans(cpm(dgel[,(dgel$samples$clus_geno_group=="X8_M_E2hom")],log=TRUE)))
        
## get histogram distribution with 10 bins at the low end of the logcpm space
h <- hist(rowmn.m,breaks = 1000)
## this dist is still neg binom so clip the ax value (very lowest end): get its corresponding bin (x axis value, i.e. log cpm)
minc <- h$breaks[which(h$counts==max(h$counts))]
minc <- h$breaks[which(h$breaks>minc)][1]

## get the corresponding smallest-library count value for this minimum^
smollib <- min(dgel$samples[dgel$samples$clus_geno_group=="X8_M_E2hom","lib.size"])
countthresh <- (minc^2)*(as.numeric(smollib)/10^6)
        
## and convert that smallest count to the logcpm value in said smallest library to use as a low-expression threshold
cpmthresh <- log2(countthresh/(as.numeric(smollib)*10^-6))
        
## 2/14/25: make a plot to also return
mnplt <- as.data.table(rowmn.m)
setnames(mnplt,1,"V1")
## exclude genes with a mean logcpm under 0.1
mnplt <- mnplt[V1>0.1]
        
# pdf("plots/12_DEanalyses_removedsampsAndFinalNMseg/01-logCPM_cutoff_checks_10spotfilt.pdf",height=10,width=10)
ggplot(mnplt,aes(x=V1))+
  geom_histogram(bins = 1000)+
  geom_vline(xintercept=cpmthresh,col="red")+
  guides(color="none")+
  ggtitle(paste0("Genewise mean logCPM smallest group (X8 male E2hom)"))

## filter for genes with at least thresh counts in at least (smaller sex group size) samples
keep <- rowSums(cpm(dgel,log=T)>cpmthresh) >= 2

## recalc lib factors after dropping low-expressed genes
dgel <- dgel[keep,,keep.lib.sizes=FALSE]
dgel <- calcNormFactors(dgel,method = "TMM")

## clean up
rm(minc,keep,cpmthresh,countthresh,h,mnplt,rowmn.m,smollib)
gc(full=T)
```

## save
```{r}
saveRDS(dgel,"processed-data/12_DEanalyses_removedsampsAndFinalNMseg/01a-DGElist_per_25HDG75SVGlouv1_clusterSexAPO_normFilt_10spotmin.RDS")
```

## make MDS plots per pseudobulk cluster per potential variable of interest
## need to specify gene selection = "common" or itll try and compare the 600whatever samples pairwise and never get done.
```{r}
covcols <- c("Sex","APOE","Visium_slide","brnum","label")
lapply(covcols,FUN=function(cov){
  pal <- rainbow(n=length(unique(dgel$samples[,cov])))
  dgel$samples[,cov] <- as.factor(dgel$samples[,cov])
  
  png(paste0("plots/12_DEanalyses_removedsampsAndFinalNMseg/01a-Allclusjoint_",cov,"_1_2_10spotfilt.png"),width=1000,height=800)
  plotMDS(dgel,col=pal[factor(dgel$samples[,cov])],gene.selection="common",dim.plot = c(1,2),pch = 18)
  legend('bottomright', legend=levels(dgel$samples[,cov]), col=pal, cex=1, pch=18)
  dev.off()
  
  png(paste0("plots/12_DEanalyses_removedsampsAndFinalNMseg/01a-Allclusjoint_",cov,"_1_3_10spotfilt.png"),width=1000,height=800)
  plotMDS(d,col=pal[factor(d$samples[,cov])],gene.selection="common", dim.plot = c(1,3),pch = 18)
  legend('bottomright', legend=levels(d$samples[,cov]), col=pal, cex=1, pch=18)
  dev.off()
  
  png(paste0("plots/12_DEanalyses_removedsampsAndFinalNMseg/01a-Allclusjoint_",cov,"_2_3_10spotfilt.png"),width=1000,height=800)
  plotMDS(d,col=pal[factor(d$samples[,cov])],gene.selection="common", dim.plot = c(2,3),pch = 18)
  legend('bottomright', legend=levels(d$samples[,cov]), col=pal, cex=1, pch=18)
  dev.off()
})

gc(full=T)
```

# clean up
```{r}
rm(ag,agc,agcd,agsc,clus,dgels,plts)
```

#### LCNM-SEGMENTATION-SUBCLUSTER DGELists -- only LC NM+/NM- frxns. ####
#### not done yet ####
