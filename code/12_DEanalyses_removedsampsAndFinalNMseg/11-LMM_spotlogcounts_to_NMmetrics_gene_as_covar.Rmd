---
title: "11-LMM_NMmetrics_to_spotlogcounts_threeAPOEfactorizations"
author: "Bernie Mulvey"
date: "2025-06-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.height = 10,fig.width = 7,include = FALSE)
#### sets tab autocompletion for directories to begin from the directory containing the .Rproj session, instead of the script's directory if different
knitr::opts_knit$set(root.dir = here::here())

library(data.table)
library(SpatialExperiment)
require(multcomp)
require(car)
require(broom)
require(lme4)
require(parallel)
# library(SpatialFeatureExperiment)

## rstudio GUI tweaks
require(colorout)
ColorOut()
options("styler.addins_style_transformer" = "biocthis::bioc_style()")
##

## enable forked parallel processing with BiocParallel::multicoreParam, future::, etc. seemed to need this a couple times, but otherwise havent so its here as a preventative measure. part of this is adding the line 
# OBJC_DISABLE_INITIALIZE_FORK_SAFETY=YES
# to Renviron.site. see e.g. top response on https://stackoverflow.com/questions/73638290/python-on-mac-is-it-safe-to-set-objc-disable-initialize-fork-safety-yes-globall 
library(parallelly)
options(parallelly.supportsMulticore.disableOn="")
options(parallelly.fork.enable=TRUE)

## last of all, unload the base package datasets, whose data keep getting in the way of autocompletions (e.g., Theoph is priortized over TRUE)
unloadNamespace("datasets")
```

read in spe, append YRI genomic proportions, subset to NM+ cells in LC cluster
```{r}
lc3 <- readRDS("processed-data/06-countsOnly_noImgData_QCed_SPE_split_to_tissSections.RDS")

## calculate log counts
lc3 <- scater::computeLibraryFactors(lc3)
lc3 <- scater::logNormCounts(lc3)

## read in nm subclusterings
lcnm <- fread("processed-data/10_subclustering/04-LCsubclus-by-NM_otherclusts-by-LCorLCNMadjacency.txt")
lcnm <- lcnm[,.(rn,NMseg_subclus)]
lcnm <- DataFrame(lcnm,row.names=lcnm$rn)[colnames(lc3),]

## assign
colLabels(lc3) <- lcnm$NMseg_subclus

# subset to LC NM+, make rownames symbols
lcnm <- lc3[,lc3$label=="LC_NMpos"]

## Drop Br5517 (unknown anatomy/orientation), Br5276 (LC has been depleted by QC), Br5712 (unknown anatomy/orientation). Keep 6297; no LC but anatomy is right in vicinity.
lcnm <- lcnm[,!(lcnm$brnum %in% paste0("Br",c(5517,5276,5712)))]

rownames(lcnm) <- rowData(lcnm)$gene_name
rm(lc3)
gc()

## drop undetected genes
keepg <- rowSums(counts(lcnm))>0 #23744 genes detected at least once here.
lcnm <- lcnm[keepg,]

### get metadata -- only intensity and proportion for NM measures are continuous and appropriate for an LMM. (the N nm bodies and centroid signal count are both counts, and would require GLMMs). we can still inspect top genes from the continuous measures plotting across all four metrics with plots later.
flares <- fread("raw-data/ancestryAndHaplotypes/FLARE/global_ancestry_estimates.txt")
flares[ID=="Br6119",ID:="Br6119(re-dis)"]

lcnm.cd <- as.data.table(colData(lcnm),keep.rownames=T)
lcnm.cd <- lcnm.cd[,.(rn,Intensity_NM,Prop_NM,Age,Sex,APOE,brnum,capture_id,sample_id)]

### append YRI
stopifnot(all(lcnm.cd$brnum%in%flares$ID))
lcnm.cd <- merge.data.table(lcnm.cd,flares[,.(ID,YRI)],by.x="brnum",by.y="ID")

## change APOE column to model-friendly genotype. we'll use three models with different approaches for APOE: E4+/-, individual genotypes, and an ordered factor of E4-,het,hom.
lcnm.cd[,E4carrier:="No"]
lcnm.cd[APOE %in% c("E3/ E4","E4/ E4"),E4carrier:="Yes"]

lcnm.cd[,E4copies:="None"]
lcnm.cd[APOE=="E3/ E4",E4copies:="Het"]
lcnm.cd[APOE=="E4/ E4",E4copies:="Hom"]
lcnm.cd[,E4copies:=factor(E4copies,levels=c("None","Het","Hom"),ordered = TRUE)]

# recode APOE itself for model friendliess
lcnm.cd[APOE=="E2/ E2",APOE:="E2hom"]
lcnm.cd[APOE=="E2/ E3",APOE:="E2het"]
lcnm.cd[APOE=="E3/ E4",APOE:="E4het"]
lcnm.cd[APOE=="E4/ E4",APOE:="E4hom"]

lcnm.lct <- logcounts(lcnm)
lcnm.lct <- as.data.frame(as.matrix(lcnm.lct))
```

## clean up for modeling runs
```{r}
rm(lcnm,keepg,flares)
gc(full=T)
```

iterate over each gene and metric and APOE modeling specification
## note that, unlike modeling gene upon NM (expr ~ NM + covars), these models (NM ~ expr + covars) do NOT return "singular fit" warnings en masse

```{r}
setDTthreads(1,restore_after_fork=FALSE)

nmcor_apoes <- lapply(c("E4carrier","E4copies","APOE"),function(apo){
    
    nmcors <- lapply(c("Intensity_NM","Prop_NM"),function(nm){
        results <- mclapply(c(1:nrow(lcnm.lct)),mc.cores=10,FUN=function(i){
        #results <- lapply(c(1:nrow(lcnm.lct)),FUN=function(i){
         
            setDTthreads(1,restore_after_fork=FALSE)
            xpr <- lcnm.lct[i,]
            xpr <- t(xpr)
            xpr <- as.data.table(xpr,keep.rownames=T)
            xpr <- merge.data.table(xpr,lcnm.cd,by="rn")
            
            curg <- colnames(xpr)[2]
            
            setnames(xpr,2,"val")
            setnames(xpr,nm,"NMvar")
            # fit lmms
            f <- formula(paste0("NMvar ~ val + Age + Sex + YRI +", apo," + (1|brnum) + (1|brnum:capture_id) + (1|brnum:capture_id:sample_id)"))
            f2 <- formula(paste0("NMvar ~ Age + Sex + YRI + ", apo," + (1|brnum) + (1|brnum:capture_id) + (1|brnum:capture_id:sample_id)")) # no term for gene
            
            lmmnm <- lmer(f,data=xpr)
            
            ## to perform LRT test, we shouldn't use REML, so run a second non REML
            lmmnm.compare <- lmer(f,data=xpr,REML = FALSE)
            lmmno <- lmer(f2,data=xpr,REML=FALSE)
            
            ## get LRT
            lrt <- stats::anova(lmmnm.compare,lmmno)
            
            ## get anova for model coeffs in the REML NM model
            an <- as.data.table(Anova(lmmnm),keep.rownames=T)
            
            ## get model coefficients
            fixfx <- as.data.table(fixef(lmmnm),keep.rownames=T)
            setnames(fixfx,c("variable","coef"))
            ## split Sex and APO into a variable column and group column for consistency with the anova table (e.g., SexM -> Sex , M) comes out as Sex here but "SexM" for the fixef. so to make sure we keep the sex coefficients, change SexM to Sex here
            fixfx[variable=="SexM",var_group:="M"]
            fixfx[variable=="SexM",variable:="Sex"]
            # pattern to fix the APOE fixed effects will begin with the variable we're testing
            fixpat <- paste0(apo,"(.*)")
            fixfx[variable %in% grep(variable,pattern=apo,value=T),var_group:=gsub(variable,pattern=fixpat,replacement="\\1")]
            fixfx[variable %in% grep(variable,pattern=apo,value=T),variable:=apo]
            fixfx <- fixfx[variable!="(Intercept)"]
            
            ## append model coefficients
            
            an <- merge.data.table(fixfx,an,by.x="variable",by.y="rn")
            an[variable=="val",variable:=curg]
            
            ## append LRT test
            lrt <- as.data.table(lrt,keep.rownames=T)[rn=="lmmnm.compare",.(rn,Chisq,Df,`Pr(>Chisq)`,logLik)]
            ## change 'loglik' to coef; change rn to "LRTvs_no_gene_coef"
            lrt[,rn:="LRTvs_no_gene_coef"]
            setnames(lrt,"rn","variable")
            
            an <- rbind(an,lrt,fill=T)
            
            ## add the NMvar being fitted
            an[,NMvar:=nm]
            
            return(an)
        })
        names(results) <- rownames(lcnm.lct)
        return(results)
    })
    names(nmcors) <- c("Intensity_NM","Prop_NM")

    ### a handful of these return error messages indicating one of the variables is constant. https://stats.stackexchange.com/questions/366784/how-to-get-around-the-glmer-warning-downdated-vtv-is-not-positive-definite
    
    ## only retain entries that are tabular results
    nmcors2 <- lapply(nmcors,FUN=function(x){
        x[unlist(lapply(x,is.data.table))]
    })
    nmcors2 <- lapply(nmcors2,FUN=function(x){
        y <- rbindlist(x,idcol="gene_name")
        setnames(y,"Pr(>Chisq)","p")
        return(y)
    })

    return(nmcors2)
})
names(nmcors2) <- c("E4carrierYN","E4copiesOrderedFact","PerGeno")

saveRDS(nmcors2,"processed-data/12_DEanalyses_removedsampsAndFinalNMseg/11-LCNMspots_NMmetric_LMMed_by_geneLogcounts_3apoeFactorizations.RDS")
```

## rep inf
```{r}
sessionInfo()
sessioninfo::session_info()
```
